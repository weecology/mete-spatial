
# This program is to test the effects of environmental factors and dispersal 
# on species area relationship(SAR)


SAR=function(data,nx,plotdim,process="Hom.Po",
             covr=list(elev=NULL,slope=NULL,aspect=NULL,convex=NULL,dister=NULL),
             sig.t=FALSE,nsam=100,show.stage=TRUE)
{
  ###################
  #@ nx:  	numeric. The number of sample scale;
  #@ plotdim: 	vector. Plotdim[1] is x; plotdim[2] is y;
  #@ processes: 	character. All recognized processes are "Real", "Hom.Po", "Ihom.Po", 
  #               "Hom.Th", "Inhom.Th";
  #		"Real":		no theoretical assumption;
  #		"Hom.Po":   		 Homogeneous Poisson Process
  #		"Inhom.Po":  	 Inhomogeneous Poisson Process
  #		"Hom.Th":    	 Homogeneous Thomas Process
  #		"Inhom.Th":		 Inhomogeneous Thomas Process.
  #@ covr: 	list. Each element is an im object which could be generated by im() 
  #               in spatstat package. Each element should have a name;
  #@ nsam:	numeric. Repeat times in one sample scale.
  #@ show.stage: logical. Print the stage of calculation if true.
  ####################
  alpha=0.05
  envelope=FALSE
  #include required library
  library(spatstat)
  #set the windows 
  win=owin(c(0,plotdim[1]),c(0,plotdim[2]))
  #species abundance
  n=table(data$sp)
  #richness
  S=length(n)
  # species name
  sp=unique(data$sp)
  #total area
  A0=plotdim[1]*plotdim[2]
  #sample area vector
  A=exp(seq(1,log(A0),length.out=nx))
  #define quadrat shape
  qsp=plotdim[2]/plotdim[1]
  y=sqrt(qsp*A)
  x=y/qsp
  ## calculate the real SAR
  if (process=="Real"){
	  result=data.frame()
	  for (i in 1:length(A)){
		  temp1=plot.sample(data=data,subplot=c(x[i],y[i]),nsam=nsam,plotdim=plotdim)
		  result[i,1]=temp1[1]
		  result[i,2]=temp1[2]
	  }
  }
  else{
    ## calculate theoretical SAR
    if (process=="Hom.Po"){
  	  result=Hom.Po(n=n,A0=A0,A=A)
    }
    else{
      # step 1:, simulate the whole dataset
      data.new=data.frame(sp=NA,gx=NA,gy=NA)
      distance=vector()
      env.sig=matrix(NA, nrow=S, ncol=length(covr))
      pars=list()
      if (show.stage){
        print("The first stage: estimating parameter")
        print(paste("The total step in this stage:",S))
      }
      for (i in 1:S){
      	sp1=data[which(data$sp==sp[i]),]
	      #convert data format and remove duplicated data
	      data.ppp=unique(ppp(x=sp1$gx,y=sp1$gy,window=win))
      	if (process=="Inhom.Po")
	        sp1=Inhom.Po(data.ppp,covr=covr,win=win,sig.t=sig.t)
      	if (process=="Hom.Th")
	        sp1=Hom.Th(data.ppp,win=win)
	    	if (process=="Inhom.Th")
	        sp1=Inhom.Th(data.ppp,covr=covr,win=win,sig.t=sig.t,P=alpha)
	    	data.new=rbind(data.new,data.frame(sp=rep(sp[i],times=sp1$n),gx=sp1$x,gy=sp1$y))
        #record the distance
        distance[i]=attr(sp1,"distance")
      	#show stage
        if (show.stage){
          print(i)
        }
        #record parameters
        if (envelope){
	        pars[[i]]=attr(sp1,"pars")
        }
      }
      data.new=data.new[-1,]
    	#step2: generate SAR
	    result=data.frame()
    	if (show.stage){
    		print("second stage: Generate SAR")
		    print(paste("total step in this stage:",length(A)))
	    }
    	for (i in 1:length(A)){
		    temp2=plot.sample(data=data.new,subplot=c(x[i],y[i]),nsam=nsam,plotdim=plotdim)
		    result[i,1]=temp2[1]
		    result[i,2]=temp2[2]
		    if (show.stage){
			    print(i)
		    }
	    }
	  	colnames(result)=c("S.mean","S.var")
	    if (process=="Inhom.Th"){
		    names(distance)=sp
		    attr(result,"distance")=distance
			  if (sig.t){
		      colnames(env.sig)=names(covr)
		      attr(result,"env.P.value")=env.sig
		    }
	    }
    }
  }
  colnames(result)=c("S.mean","S.var")
  result$A=A
  attr(result,"process")=process
  return(result)
}

Hom.Po=function(n,A0,A){
  # 1. random-placement model or Homogeneous Poisson process
  ## Arguements
  # n: vector of species abundance
  # A0: total sample area
  # A: vector of sub-region area
  ##
  #N: total number of species
  N=length(n)
	temp1=apply(matrix(A),1,function(x) sum((1-x/A0)^n))
	temp2=apply(matrix(A),1,function(x) sum((1-x/A0)^(n*2)))
	S.mean=N-temp1
  S.var=temp1-temp2
  return(data.frame(S.mean,S.var))
}

Inhom.Po=function(data.ppp,covr,win,sig.t){
  #simulate inhomogeneous Poisson process
  sig=NULL
  fu=formu(names(covr))
  # using maximum likelihood method to estimate parameter
  data.ppm=ppm(data.ppp,fu,covariates=covr)
  # simulate species distribution using the above fitted model
  re=rmh.ppm(data.ppm)
  return(re)
}


Hom.Th=function(data.ppp,win){
  # Homogeneous Thomas process
  #using CRV process to simulate the process
  #and estimate density
	data.ppm=ppm(data.ppp)
	lambda=exp(data.ppm$coef[[1]])
	K=Kest(data.ppp,correction="border")
	#pre-hand K result, remove NA in K
	chose=which(!is.na(K$border) & K$border==max(K$border,na.rm=T))[1]
	K=K[1:chose,]
	#using minimum contrast method to estimate sigma, mu
	Thom=thomas.estK.my(K, c(sigma2=K$r[chose]/4, kappa=1/K$border[chose]),lambda=lambda,
                      maxit=1e+5)
	Thom.par=Thom$modelpar
	if (Thom.par[3]<1e-5 | Thom$opt$convergence!=0) re=rmh(data.ppm)
	else re=rThomas.my(kappa=Thom.par[1],sigma=Thom.par[2],mu=Thom.par[3],win=win)
	attr(re,"distance")=Thom.par[2]
  return(re)
}


Inhom.Th=function(data.ppp,covr,win,sig.t,P=0.05,simla=TRUE){
  # inhomogeneous Thomas process
  sig=rep(NA,times=length(covr))
  fu=formu(names(covr))
  # using maximum likelihood method to estimate parameter
  data.ppm=ppm(data.ppp,fu,covariates=covr)
  #estimate density and location density
  lambda=predict(data.ppm,ngrid=c(covr[[1]]$dim[1],covr[[1]]$dim[2]))
  lambda2=predict(data.ppm,locations=list(x=data.ppp$x,y=data.ppp$y))
	# calculate inhomogeneous K function
  K=Kinhom(data.ppp,lambda2,correction="border")
  #pre-hand K result, remove NA in K
  chose=which(!is.na(K$border) & K$border==max(K$border,na.rm=T))[1]
  K=K[1:chose,]
  #using minimum contrast method to estimate sigma, mu
  Thom=thomas.estK.my(K, c(sigma2=K$r[chose]/4, kappa=1/K$border[chose]), lambda=lambda, 
                      maxit=1e+5 )
  Thom.par=Thom$modelpar
  print(Thom.par[2])
  if (sig.t & Thom.par[2]<=200)
    sig=confi.inter(covr,beta=coef(data.ppm),sigma=Thom.par[2],kappa=Thom.par[1],P)
  if (simla){
    # prepare for thinning process
    cst=coef(data.ppm)[1]
    lambda.c=lambda
    M=max(lambda.c$v)
    # pre-thinning density of offspring 
    Thom.par[3]=M/Thom.par[1]
  	if (Thom.par[3]<1e-4 | Thom.par[1]*win$xrange[2]*win$yrange[2] < 1 |Thom.par[3]>1e+4){
	  	re=rmh(data.ppm)
		  while (re$n==0)
			  re=rmh(data.ppm)
    }
    else{
		  re=rThomas.my(kappa=Thom.par[1],sigma=Thom.par[2],mu=Thom.par[3],win=win)
	    while (re$n==0)
		    re=rThomas.my(kappa=Thom.par[1],sigma=Thom.par[2],mu=Thom.par[3],win=win)
   		#thinning process
	  	lambda.c$v=lambda.c$v/M
		  re=rthin(re,lambda.c)
	  }
  }
  else{
    re=ppp(x=c(1:2),y=c(1:2),window=win)
  }
  attr(re,"sig")=sig
  attr(re,"distance")=Thom.par[2]
  return(re)
}


formu=function(name,del=NULL){
  # Formula construct
  l=length(name)
  for (i in 1:l){
	  if (i==1) fu=paste("~",name[i])
	  else fu=paste(fu,"+",name[i])
  }
  if (!is.null(del))
    fu=paste(fu,del)
  fu=as.formula(fu)
  return(fu)
}

#adjust windows for covariance
setwin=function(data,covr,plotdim){
  n=length(covr)
  x.min=x.max=y.min=y.max=numeric()
  for (i in 1:n){
	  x.min[i]=covr[[i]]$xrange[1]
	  x.max[i]=covr[[i]]$xrange[2]
	  y.min[i]=covr[[i]]$yrange[1]
	  y.max[i]=covr[[i]]$yrange[2]
  }
  x.max=min(x.max,plotdim[1])
  y.max=min(y.max,plotdim[2])
  x.min=max(x.min)
  y.min=max(y.min)
  win=owin(c(x.min,x.max),c(y.min,y.max))
  plotdim=c(x.max-x.min,y.max-y.min)
  data=data[which(data$gx>=x.min & data$gx<=x.max & data$gy>=y.min & data$gy<=y.max),]
  data$gx=data$gx-min(data$gx)
  data$gy=data$gy-min(data$gy)
  for (i in 1:n){
    covr[[i]]=covr[[i]][win]
	  covr[[i]]$xrange=c(0,plotdim[1])
	  covr[[i]]$yrange=c(0,plotdim[2])
	  covr[[i]]$xcol=covr[[i]]$xcol-x.min
	  covr[[i]]$yrow=covr[[i]]$yrow-y.min
  }
  return(list(plotdim,data,covr))
}

# Soil data transformation
soil.tran=function(soil,url){
  library(foreign)
  library(spatstat)
  n=length(soil)
  wd=getwd()
  setwd(url)
  result=list()
  for (i in 1:n){
	  da=read.dbf(paste(soil[i],".dbf",sep=""))
	  da=matrix(da[,2],nrow=121,ncol=246,byrow=T)
	  da=da[sort(1:121,decreasing=T),]
	  result[[i]]=im(da,xcol=seq(10,990,by=4),yrow=seq(10,490,by=4))
  }
  names(result)=soil
  setwd(wd)
  return(result)
}

rThomas.my=function (kappa, sigma, mu, win = owin(c(0, 1), c(0, 1))) 
{
  # modified rThomas function
  stopifnot(is.numeric(sigma) && length(sigma) == 1 && sigma > 0)
  stopifnot(is.numeric(mu) && length(mu) == 1 && mu >= 0)
	#new function 1
  thomclus <- function(x0, y0, sigma, mu,n) {
                x <- rnorm(n, mean = x0, sd = sigma)
                y <- rnorm(n, mean = y0, sd = sigma)
                return(list(x = x, y = y))
              }
	#new function 2
	check <- function(n,mu){
		         off.n=rpois(n,mu)
		         chose=which(off.n>=1)
		         off.n=off.n[chose]
		         return(list(chose,off.n))
	         }
  result <- rNeymanScott.my(kappa, 4 * sigma, thomclus, check ,win, sigma = sigma, 
  mu = mu)
  return(result)
}

rNeymanScott.my=function (kappa, rmax, rcluster, ncluster, win = owin(c(0, 1), c(0, 1)), 
                          mu, ..., lmax = NULL) 
{
  #Calculate the modified rNeyman-Scott function; make the function work faster 
  # and be capability for large datasets; disable the parent information calculation
  win <- as.owin(win)
  frame <- bounding.box(win)
  dilated <- owin(frame$xrange + c(-rmax, rmax), frame$yrange + c(-rmax, rmax))
  if (is.im(kappa) && !is.subset.owin(as.owin(kappa), dilated)) 
    stop(paste("The window in which the image", sQuote("kappa"), 
               "is defined\n", "is not large enough to contain the dilation of the window", 
               sQuote("win")))
	total=mean(kappa)*win$xrange[2]*win$yrange[2]	
	if (total<=1e+5){
		parents <- rpoispp.my(kappa, lmax = lmax, win = dilated)
		result <- ppp(numeric(0), numeric(0), window = win)
		parentid <- numeric(0)
		if (parents$n > 0) {
			chose=ncluster(n=parents$n, mu=mu)
			if (length(chose[[1]])>0){
				for (i in 1:length(chose[[1]])) {
					k=chose[[1]][i]
					n=chose[[2]][i]
					cluster <- rcluster(x0=parents$x[k], y0=parents$y[k], n=n, ...)
					chos.off<- which(cluster$x>=win$xrange[1] & cluster$x<=win$xrange[2] 
									& cluster$y>=win$yrange[1] & cluster$y<=win$yrange[2])
					if (i==1) {
						offsp.x=cluster$x[chos.off]
						offsp.y=cluster$y[chos.off]
					}
          else{
						offsp.x=c(offsp.x,cluster$x[chos.off])
						offsp.y=c(offsp.y,cluster$y[chos.off])
					}
					#parentid <- c(parentid, rep(i, cluster$n))
				}
				result <- ppp(offsp.x, offsp.y, window = frame, check = FALSE)
			}
		}
	}
  else{
		times=ceiling(total/1e+5)
		kappa=kappa/times
		pp.j=0
		for (j in 1:times){
		  parents <- rpoispp.my(kappa, lmax = lmax, win = dilated)
		  result <- ppp(numeric(0), numeric(0), window = win)
		  parentid <- numeric(0)
		  if (parents$n > 0) {
			  chose=ncluster(n=parents$n, mu=mu)
			  if (length(chose[[1]])>0){
				  for (i in 1:length(chose[[1]])) {
					  k=chose[[1]][i]
					  n=chose[[2]][i]
					  cluster <- rcluster(x0=parents$x[k], y0=parents$y[k], n=n,...)
					  chos.off<- which(cluster$x>=win$xrange[1] & cluster$x<=win$xrange[2] &
						      			     cluster$y>=win$yrange[1] & cluster$y<=win$yrange[2])
					  if (i==1) {
						  offsp.x=cluster$x[chos.off]
						  offsp.y=cluster$y[chos.off]
					  }
            else{
						  offsp.x=c(offsp.x,cluster$x[chos.off])
						  offsp.y=c(offsp.y,cluster$y[chos.off])
					  }
					  if (i==1) 
              pp.j=pp.j+1
					  #parentid <- c(parentid, rep(i, cluster$n))
				  }
				}
			  if (pp.j==1){
			    offsp.x.to=offsp.x
			    offsp.y.to=offsp.y
		    }
		    if (pp.j>1){
			    offsp.x.to=c(offsp.x.to,offsp.x)
			    offsp.y.to=c(offsp.y.to,offsp.y)
		    }
		  }
		}
		result <- ppp(offsp.x.to, offsp.y.to, window = frame, check = FALSE)
		rm(offsp.x.to,offsp.y.to)
	}
  #attr(result, "parents") <- parents
  #attr(result, "parentid") <- parentid
  return(result)
}

rpoispp.my=function (lambda, lmax = NULL, win = owin(c(0, 1), c(0, 1)), ...) 
{
    win <- if (is.im(lambda)) 
        rescue.rectangle(as.owin(lambda))
    else as.owin(win)
    if (is.numeric(lambda)) 
        return(runifpoispp(lambda, win))
    if (is.null(lmax)) {
        imag <- as.im(lambda, win, ...)
        summ <- summary(imag)
        lmax <- summ$max + 0.05 * diff(summ$range)
    }
    if (is.function(lambda)) {
        X <- runifpoispp(lmax, win)
        if (X$n == 0) 
            return(X)
        prob <- lambda(X$x, X$y, ...)/lmax
        u <- runif(X$n)
        retain <- (u <= prob)
        X <- X[retain, ]
        return(X)
    }
    if (is.im(lambda)) {
        X <- runifpoispp(lmax, win)
        if (X$n == 0) 
            return(X)
        prob <- lambda[X]/lmax
        u <- runif(X$n)
        retain <- (u <= prob)
        X <- X[retain, ]
		rm(prob);rm(retain);rm(u)
        return(X)
    }
    stop("'lambda' must be a constant, a function or an image")
}




thomas.estK.my=function (X, startpar = c(kappa = 1, sigma2 = 1), maxit=1e+4, lambda = NULL, 
    q = 1/4, p = 2, rmin = NULL, rmax = NULL) 
{
    dataname <- deparse(substitute(X))
    if (inherits(X, "fv")) {
        K <- X
    }
    else if (inherits(X, "ppp")) {
        K <- Kest(X)
        dataname <- paste("Kest(", dataname, ")", sep = "")
        lambda <- summary(X)$intensity
    }
    else stop("Unrecognised format for argument X")
    startpar <- check.named.vector(startpar, c("kappa", "sigma2"))
    theoret <- function(par, rvals) {
        if (any(par <= 0)) 
            return(rep(Inf, length(rvals)))
        pi * rvals^2 + (1 - exp(-rvals^2/(4 * par[2])))/par[1]
    }
    result <- mincontrast.my(K, theoret, startpar,maxit=maxit, ctrl = list(q = q, 
        p = p, rmin = rmin, rmax = rmax), fvlab = list(label = "Kfit(r)", 
        desc = "minimum contrast fit of Thomas process"), explain = list(dataname = dataname, 
        fname = "K", modelname = "Thomas process"))
    par <- result$par
    names(par) <- c("kappa", "sigma2")
    result$par <- par
    mu <- if (is.numeric(lambda) && length(lambda) == 1) 
        lambda/result$par[["kappa"]]
    else NA
    result$modelpar <- c(kappa = par[["kappa"]], sigma = sqrt(par[["sigma2"]]), 
        mu = mu)
    result$internal <- list(model = "Thomas")
    return(result)
}


mincontrast.my=function (observed, theoretical, startpar,maxit=1e+4,..., ctrl = list(q = 1/4, 
    p = 2, rmin = NULL, rmax = NULL), fvlab = list(label = NULL, 
    desc = "minimum contrast fit"), explain = list(dataname = NULL, 
    modelname = NULL, fname = NULL)) 
{
    verifyclass(observed, "fv")
    stopifnot(is.function(theoretical))
    if (!any("par" %in% names(formals(theoretical)))) 
        stop(paste("Theoretical function does not include an argument called", 
            sQuote("par")))
    ctrl <- resolve.defaults(ctrl, list(q = 1/4, p = 2, rmin = NULL, 
        rmax = NULL))
    fvlab <- resolve.defaults(fvlab, list(label = NULL, desc = "minimum contrast fit"))
    explain <- resolve.defaults(explain, list(dataname = NULL, 
        modelname = NULL, fname = NULL))
    rmin <- ctrl$rmin
    rmax <- ctrl$rmax
    if (!is.null(rmin) && !is.null(rmax)) 
        stopifnot(rmin < rmax && rmin >= 0)
    else {
        alim <- attr(observed, "alim")
        if (is.null(rmin)) 
            rmin <- alim[1]
        if (is.null(rmax)) 
            rmax <- alim[2]
    }
    argu <- attr(observed, "argu")
    rvals <- observed[[argu]]
    valu <- attr(observed, "valu")
    obs <- observed[[valu]]
    if (max(rvals) < rmax) 
        stop(paste("rmax=", signif(rmax, 4), "exceeds the range of available data", 
            "= [", signif(min(rvals), 4), ",", signif(max(rvals), 
                4), "]"))
    sub <- (rvals >= rmin) & (rvals <= rmax)
    rvals <- rvals[sub]
    obs <- obs[sub]
    obsq <- obs^(ctrl$q)
    objective <- function(par, obsq, theoretical, rvals, qq, 
        pp, rmin, rmax, ...) {
        theo <- theoretical(par = par, rvals)
        if (!is.vector(theo) || !is.numeric(theo)) 
            stop("theoretical function did not return a numeric vector")
        if (length(theo) != length(obs)) 
            stop("theoretical function did not return the correct number of values")
        discrep <- (abs(theo^qq - obsq))^pp
        return(sum(discrep))
    }
    minimum <- optim(startpar, fn = objective, obsq = obsq, theoretical = theoretical, 
        rvals = rvals, qq = ctrl$q, pp = ctrl$p, rmin = rmin, 
        rmax = rmax, maxit=maxit, ...)
    fittheo <- theoretical(minimum$par, rvals, ...)
    label <- fvlab$label
    desc <- fvlab$desc
    if (is.null(label)) 
        label <- paste("fit(", argu, ")", collapse = "")
    fitfv <- bind.fv(observed[sub, ], data.frame(fit = fittheo), 
        label, desc)
    result <- list(par = minimum$par, fit = fitfv, opt = minimum, 
        ctrl = list(p = ctrl$p, q = ctrl$q, rmin = rmin, rmax = rmax), 
        info = explain)
    class(result) <- c("minconfit", class(result))
    return(result)
}



# 2. sample function

plot.sample=function(data,subplot=c(20,20),plotdim=c(600,400),nsam=10){
# @ subplot: the size of subplot
# @ plotdim: the size of whole plot
# @ smd: sampling method, "regular" or "random"
# @ nsam: the number of sampling if the smd is equal to "random"
# @ raplace: logical.
# @ shape: the shape of subplot: circle or square
	plotdim=round(plotdim)
	subplot=round(subplot)
    point.x=numeric()
    point.y=numeric()
	
    point.x=runif(nsam,min=0,max=plotdim[1]-subplot[1])
    point.y=runif(nsam,min=0,max=plotdim[2]-subplot[2])
	
	S=numeric()
	if (!all(subplot==plotdim)){
    for (i in 1:nsam){
	   
        sample= data$gx>= point.x[i] & data$gx <= (point.x[i]+subplot[1]) & 
        data$gy>= point.y[i] & data$gy <= (point.y[i]+subplot[2])
		S[i]=length(unique(data$sp[sample]))
		
    }
	S.mean=mean(S,na.rm=T)
	S.var=var(S,na.rm=T)
	}else{
	S.mean=length(unique(data$sp))
	S.var=0
	}
return(c(S.mean,S.var))
}
